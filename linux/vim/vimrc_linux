
"-------------------------------------------------------------------------------
" encoding, font, etc.

" normally 'encoding' will be equal to your current locale
" you can detect the locale via v:lang, e.g.,
"     if v:lang =~ "utf8$" || v:lang =~ "UTF-8$"
" and export LANG=... in ~/.bashrc to set the locale, e.g.,
"     export LANG=zh_CN.utf8
"set encoding=utf-8
set fileencodings=utf-8,ucs-bom,gbk,gb2312,latin1,cp936

" for chinese
set formatoptions+=mM

"-------------------------------------------------------------------------------
" general

set nocompatible
set history=400

set nobackup
set nowritebackup
set noswapfile

set autoread " when file is changed outside

"filetype plugin on
filetype indent on

let mapleader = ","
let g:mapleader = ","

nmap <leader>w :w!<CR>
nmap <leader>f :find<CR>

set ffs=unix,dos,mac
nmap <leader>fd :set ff=dos<CR>
nmap <leader>fu :set ff=unix<CR>

" Remove the Windows ^M
noremap <leader>m :%s/<C-V><C-M>//ge<CR>

" Restore cursor to file position in previous editing session
set viminfo='10,\"100,:20,%,n~/.viminfo
au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif

"-------------------------------------------------------------------------------
" format

set nofoldenable
set foldlevel=0

set autoindent
set smartindent
set cindent " c-style indeting

func! ExpandTab(tabsize)
    " for tabstop: default 8. better not to change it
    exec ":set expandtab"
    exec ":set shiftwidth=" . a:tabsize
    exec ":set softtabstop=" . a:tabsize
endfunc

"call ExpandTab(4) " default
au FileType html :call ExpandTab(2)<CR>

nnoremap <leader>t2 :call ExpandTab(2)<CR>
nnoremap <leader>t4 :call ExpandTab(4)<CR>

set smarttab

" linebreak makes sense only when wrap is on & list is off(nolist)
set linebreak
set textwidth=80
set wrap " lines (nowrap)


"-------------------------------------------------------------------------------
" color

if &t_Co > 2 || has("gui_running")
    set background=dark
    syntax enable
    colorscheme ron
    set hlsearch
    map <silent> <leader><CR> :noh<CR>
    au BufEnter * :syntax sync fromstart
endif


"-------------------------------------------------------------------------------
" user interface

if has("mouse") | set mouse=a | endif

set so=7 " number of lines to curor when moving vertically
set wildmenu " enhanced command line completion
set ruler
set cmdheight=2
set number
set lazyredraw
set hidden " switch buffers without saving
" allow backspacing over everything in insert mode
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

"set ignorecase " for search
set noignorecase
set incsearch

set magic

set noerrorbells
set novisualbell

set showmatch " bracets
set matchtime=1 " 1/10 second to blink

set laststatus=2 " always show statusline

function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction

" format the status line
set statusline=%<%f\ -\ %r%{CurDir()}%h\ %h%m%r%=%k[%{(&fenc==\"\")?&enc:&fenc}%{(&bomb?\",BOM\":\"\")}]\ \ %-16.(%l/%L,%c%V%)\ \ %P

" change cwd to the dir of current file
map <leader>cfd :cd %:p:h<CR>

" :set list or :set nolist
function! ListOrNot()
    if &list
        execute ":set nolist"
    else
"        set list listchars=tab:>-,trail:-,eol:$,extends:>,precedes:<
        execute ":set list listchars=tab:>-,trail:-,eol:$"
    endif
endfunction

map <buffer> <leader>ls :call ListOrNot()<CR>


"-----------------------------------------------------------------------------
" visual

" from an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"
    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")
    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    else
        execute "normal /" . l:pattern . "^M"
    endif
    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>


"-------------------------------------------------------------------------------
" window

map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

" vertically explore the dir of current file
map <F2> :Vex<CR>25<C-W><


"-------------------------------------------------------------------------------
" buffer

" switch buffers with arrows
map <right> :bn<CR>
map <left>  :bp<CR>
map <up>    :bf<CR>
map <down>  :bl<CR>

" list buffers
map <leader>bl :ls<CR>
" add buffer
map <leader>ba :bad<space>
" delete buffer (write first)
map <leader>bd :w!<CR>:bd<CR>
" open a buffer for temporary use (e.g. copy)
map <leader>bt :e ~/tempbuf<CR>


"-------------------------------------------------------------------------------
" tab
if v:version >= 700
    map <leader>tn :tabnew %<CR>
    map <leader>te :tabedit
    map <leader>tc :tabclose<CR>
    map <leader>tm :tabmove
    try
        set switchbuf=usetab
        set stal=2
    catch
    endtry
endif


"-------------------------------------------------------------------------------

" abbr.
iab xname Adam Gu
iab xmail sprinfall@gmail.com
iab xfile <c-r>=fnamemodify(bufname("%"), ":t")<CR>

if exists("*strftime")
    " abbr. for date/time
    iab xdate <c-r>=strftime("%Y-%m-%d")<CR>
    iab xtime <c-r>=strftime("%H:%M:%S")<CR>

    " shortcut for date/time
    imap <buffer> <silent> <leader>d <c-r>=strftime("%Y %b %d %X")<CR>
endif

iab xline ----------------------------------------
iab xwave ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
iab xeq ========================================

"-------------------------------------------------------------------------------

function! DeleteTrailingWS()
    execute "normal mz"
    %s/\s\+$//ge
    execute "normal `z"
endfunction

" uncomment this if you need
"au BufWrite * :call DeleteTrailingWS()<CR>
map <C-F5> :call DeleteTrailingWS()<CR>

" remove indenting on empty lines
map <F3> :%s/\s*$//g<CR>:noh<CR>''<CR>


"-------------------------------------------------------------------------------
" command line

function! Cwd()
    let cwd = getcwd()
    return "e " . cwd
endfunction

function! DeleteTillSlash()
    let g:cmd = getcmdline()
    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
    if g:cmd == g:cmd_edited
        let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
    endif
    return g:cmd_edited
endfunction

function! CurrentFileDir(cmd)
    return a:cmd . " " . expand("%:p:h") . "/"
endfunction

" Smart mappings on the command line
cno $h e ~/
cno $d e ~/Desktop/
cno $j e ./

cno $q <C-\>eDeleteTillSlash()<CR>

cno $c e <C-\>eCurrentFileDir("e")<CR>

cno $tc <C-\>eCurrentFileDir("tabnew")<CR>
cno $th tabnew ~/
cno $td tabnew ~/Desktop/


"-------------------------------------------------------------------------------
" spelling check

if has("spell")
    " :set spell or :set nospell
    function! SpellOrNot()
        if &spell
            execute ":set nospell"
        else
            execute ":set spell"
        endif
    endfunction

    set spelllang=en_us

    " sc: spell check
    map <buffer> <leader>sc :call SpellOrNot()<CR>
    map <leader>sn ]s
    map <leader>sp [s
    map <leader>sa zg
    map <leader>s? z=
endif " spell

"-------------------------------------------------------------------------------
" Filetype

" vim
au FileType vim map <buffer> <leader><space> :w!<CR>:source %<CR>

" TODO
" Run in the Python interpreter
function! Python_Eval_VSplit() range
   let src = tempname()
   let dst = tempname()
   execute ": " . a:firstline . "," . a:lastline . "w " . src
   execute ":!python " . src . " > " . dst
   execute ":pedit! " . dst
endfunction
"au FileType python vmap <F5> :call Python_Eval_VSplit()<CR>
"au FileType python nmap <F5> :!python %<CR>

func! Run_python()
    exec ":!python %"
endfunc

"-------------------------------------------------------------------------------
" filetype - haskell

" Call a function only if it exists.
func! CallIf(afunc)
    if exists("*".a:afunc) 
        exec "call ".a:afunc."()"
    endif
endfunc

func! Bld_haskell()
    exec ":!ghc --make %"
    "-Wall
endfunc

func! Bld()
    call CallIf("Bld_".tolower(&filetype))
endfunc

func! Clr_haskell()
    " ISSUE: Windows only...
    call system("DEL *.hi *.o *.exe *.manifest")
endfunc
func! Clr()
    call CallIf("Clr_".tolower(&filetype))
endfunc

source ~/.vimrc_func.vim
func! Run_haskell()
    let l:execname = RmSuffix(bufname("%"))
    exec ":!" . l:execname
"    let result = tempname()
"    exec ":!" . l:execname . " > " . result
"    exec ":pedit! " . result
endfunc
func! Run()
    call CallIf("Run_".tolower(&filetype))
endfunc

command! Bld call Bld()
command! Clr call Clr()
command! Run call Run()
nmap <F7> :Bld<CR>
nmap <C-F7> :Clr<CR>
nmap <F5> :Run<CR>

"-------------------------------------------------------------------------------
" tool - cscope

let g:cscope_path = "/usr/bin/cscope"

if has("cscope") && filereadable("/usr/bin/cscope")
    set csprg=/usr/bin/cscope
    " 0: search cscope db first; 1: search tag files first
    set csto=0 " default
    " search cscope db as well as the tag files
    set cst " default: nocst

    " no message for success/failure in adding cscope db
    set nocsverb " default

    if filereadable("cscope.out")
        " add any database in current directory
        cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
    " set it after adding the cscope db
"    set csverb

    " tips for :cstag
    " :cstag can use the tag file produced by ctags while :cs find cannot
    " and if 'sct' is set, commands like <C-]> or :tag will use :cstag instead
    " of the default :tag behavior
    " so no extra mapping is provided here for :cstag. use <C-]> directly

    " mappings for :cs find
    nmap <leader>S :cs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <leader>G :cs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <leader>C :cs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <leader>T :cs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <leader>E :cs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <leader>F :cs find f <C-R>=FileName(expand("<cfile>"))<CR><CR>
"    nmap <leader>F :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <leader>I :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <leader>D :cs find d <C-R>=expand("<cword>")<CR><CR>

    " mappings for :cs find with horizontally splitting window
    nmap <leader><leader>S :scs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <leader><leader>G :scs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <leader><leader>C :scs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <leader><leader>T :scs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <leader><leader>E :scs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <leader><leader>F :scs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <leader><leader>I :scs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <leader><leader>D :scs find d <C-R>=expand("<cword>")<CR><CR>

    " update the cscope db
    " add *.cc, *.cxx, etc if you need
    map <silent> <F11> :!cscope -Rbk *.h *.cc <CR>:cs add cscope.out<CR>
endif " cscope

"-------------------------------------------------------------------------------
" tool - ctags

let g:ctags_path = "/usr/bin/ctags"
let g:ctags_name = "ctags"

if filereadable(g:ctags_path)
    set tags+=tags
    map <silent> <F12> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>:set tags+=tags<CR>
"    set tags+=/usr/local/include/ace/tags
endif

"-------------------------------------------------------------------------------
" plugin - taglist

"map <F8> :TlistToggle<CR>
"let Tlist_Enable_Fold_Column = 1
"let Tlist_File_Fold_Auto_Close = 1
"let Tlist_Close_On_Select = 1
"let Tlist_Show_Menu = 1
"let Tlist_Sort_Type = "name"

"-------------------------------------------------------------------------------
" plugin - omnicppcomplete

set completeopt = "menu" " no preview

"let OmniCpp_DefaultNamespaces = ["std"]
let OmniCpp_NamespaceSearch = 2 " search in included files too
let OmniCpp_DisplayMode = 1 " always show all members for class scope(::)
let OmniCpp_ShowPrototypeInAbbr = 1 " useful for overloaded functions
let OmniCpp_MayCompleteDot = 0 " default 1
let OmniCpp_MayCompleteArrow = 0 " default 1
let OmniCpp_MayCompleteScope = 0 " default 0 (::)
let OmniCpp_SelectFirstItem = 2 " default 0

imap <C-J> <C-X><C-O>

"-------------------------------------------------------------------------------
" plugin - EnhancedCommentify
let g:EnhCommentifyMultiPartBlocks = 'yes'

